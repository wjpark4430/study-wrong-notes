# 📌 Oracle에서 테이블 별칭 사용 시 `AS` 금지 (오답노트)

| 항목     | 설명                                                       |
| ------ | -------------------------------------------------------- |
| 배경 개념  | SQL에서 테이블에 별칭(alias)을 부여할 때 사용하는 구문                      |
| 표준 문법  | `SELECT T.* FROM 테이블명 T` ← 테이블 별칭은 **AS 없이** 공백으로 부여     |
| 오류 포인트 | Oracle에서는 테이블 별칭에 **`AS` 키워드 사용 불가** → `TAB AS T`는 오류 발생 |
| 허용 예시  | `SELECT T.* FROM TAB T` ← ✅ 정상 동작                        |
| 금지 예시  | `SELECT T.* FROM TAB AS T` ← ❌ Oracle에서는 **문법 오류 발생**    |

---

## 문제

![5번 문제](../images/5.png)

---

## 오답 기록

### ❌ 오답: 3번

* `SELECT T.* FROM TAB AS T` → Oracle에서는 **`AS` 키워드로 테이블에 별칭 부여 불가**
* **구문 오류 발생**하며 실행되지 않음

### ✅ 정답: 3번

* 나머지 문장은 Oracle에서 정상 실행되며, 결과도 모두 동일
* **오직 3번만 오류가 발생하여 결과가 다름**

---

## 추가 설명 & 복습 포인트

* **컬럼에는 `AS` 사용 가능**, 테이블에는 ❌

  * 예: `SELECT col1 AS c1 FROM TAB` → 가능
  * 예: `SELECT * FROM TAB AS T` → Oracle에서 오류
* 다른 DBMS (MySQL, PostgreSQL 등)에서는 `AS` 허용되므로, DBMS별 차이 반드시 인지
* 실무/시험에서 Oracle 기준이라면 **문법 제한 사항**을 미리 숙지할 것

---

## 느낀 점

* **DBMS마다 SQL 문법에 차이 있음**을 확실히 체감
* 평소에 자주 쓰지 않는 구문이라도 Oracle에선 예외 사항을 **꼼꼼히 체크**해야 함
* 단순 결과 비교 문제가 아닌 **문법 자체 오류**도 주의해서 보기 분석할 것

---

# 📌 ANY 연산자 & 상사-부하 관계 해석 실수 (오답노트)

| 항목     | 설명                                                      |
| ------ | ------------------------------------------------------- |
| 배경 개념  | SQL에서 `ANY`는 **하나라도 조건을 만족하면 TRUE**가 되는 다중행 비교 연산자      |
| 사용 구조  | `컬럼 >= ANY (서브쿼리)` → 서브쿼리 결과 중 최소값 이상이면 TRUE            |
| 핵심 포인트 | `A.MANAGER_ID = B.EMPLOYEE_ID` → **A는 부하직원**, **B는 상사** |
| 오해 요소  | 부하와 상사의 위치, 연봉 비교 방향을 잘못 이해하면 정반대 의미로 해석됨               |

---

## 문제

![21-1번 문제](../images/21-1.png)


---

## 오답 기록

### ❌ 오답: 3번 — "어떤 상사보다 연봉이 높은 부하 직원"

* **`A.MANAGER_ID = B.EMPLOYEE_ID` 해석 오류**
  → A가 상사이고 B가 부하라고 착각했음
* 하지만 실제로는 **A가 부하, B가 상사**
* `B.SALARY >= ANY A.SALARY`: **상사 B의 연봉이, 자신을 부하로 둔 A 중 한 명 이상보다 크거나 같을 때**

---

## ✅ 정답: 1번 — "어떤 부하 직원보다도 연봉이 높은 상사"

* 상사의 연봉이 부하 중 한 명이라도 보다 크거나 같으면 조건 만족
* 즉, **부하들 중 최소 연봉보다 높은 상사**들을 찾는 쿼리

---

## 추가 설명 & 복습 포인트

| 비교 연산자   | 의미                       | 예시 (서브쿼리 결과: 100, 200, 300)     |
| -------- | ------------------------ | ------------------------------- |
| `>= ANY` | 서브쿼리 중 **최소값 이상이면** TRUE | `250 >= ANY(...)` → TRUE (≥100) |
| `> ALL`  | 서브쿼리 중 **최댓값 초과해야** TRUE | `250 > ALL(...)` → FALSE (X)    |

**주의할 점**:

* `A.MANAGER_ID = B.EMPLOYEE_ID`에서 **B가 상사**임을 꼭 기억할 것
* 관계를 잘못 이해하면 연봉 비교 방향이 바뀜
* 테이블 조인 시 **역할(상사 vs 부하)** 구분이 매우 중요

---

## 느낀 점

* 테이블 조인에서 `A`, `B` 역할을 **직관적으로 오해**함
* 문제 해석 시에는 관계형 조건을 먼저 **자연어로 해석하고**, 그 다음 연산자의 의미를 연결해야 함
* 다음부터는 **"누가 누구의 상사인가?"** 관계 먼저 체크하고 조건을 해석